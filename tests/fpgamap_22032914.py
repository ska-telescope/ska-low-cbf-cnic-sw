# M&C Python client include file for trafgen FPGA
# Note that this file uses register (not AXI byte) addresses and offsets
FPGAMAP = {
    "cmac": {
        "slaves": {
            "cmac_stats_interface": {
                "fields": {
                    "cmac_stat_reset": {
                        "access_mode": "RW",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Clears all stat counters. Set bit[0] to 1, this will trigger a reset process, this register will still need to set back to 0.",
                        "start": 0,
                        "step": 1,
                        "stop": 1,
                        "width": 8,
                    },
                    "cmac_stat_rx_bad_code": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for 64B/66B code violations.",
                        "start": 29,
                        "step": 1,
                        "stop": 30,
                        "width": 32,
                    },
                    "cmac_stat_rx_bad_fcs": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "A packet was received with a bad FCS but not a stomped FCS.",
                        "start": 7,
                        "step": 1,
                        "stop": 8,
                        "width": 32,
                    },
                    "cmac_stat_rx_bad_preamble": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment bad preamble. Packet received was preceded by a invalid preamble.",
                        "start": 31,
                        "step": 1,
                        "stop": 32,
                        "width": 32,
                    },
                    "cmac_stat_rx_bad_sfd": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment bad SFD. Packet received was preceded by a invalid SFD.",
                        "start": 30,
                        "step": 1,
                        "stop": 31,
                        "width": 32,
                    },
                    "cmac_stat_rx_broadcast": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for good broadcast packets.",
                        "start": 24,
                        "step": 1,
                        "stop": 25,
                        "width": 32,
                    },
                    "cmac_stat_rx_fragment": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for packets shorter than min packet length with bad FCS.",
                        "start": 28,
                        "step": 1,
                        "stop": 29,
                        "width": 32,
                    },
                    "cmac_stat_rx_multicast": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for good multicast packets.",
                        "start": 23,
                        "step": 1,
                        "stop": 24,
                        "width": 32,
                    },
                    "cmac_stat_rx_oversize": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for packets longer than ctl_rx_max_packet_len with good FCS.",
                        "start": 25,
                        "step": 1,
                        "stop": 26,
                        "width": 32,
                    },
                    "cmac_stat_rx_packet_1024_1518_bytes": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for good and bad packets received that contain 1024 to 1518 bytes.",
                        "start": 13,
                        "step": 1,
                        "stop": 14,
                        "width": 32,
                    },
                    "cmac_stat_rx_packet_128_255_bytes": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for good and bad packets received that contain 128 to 255 bytes.",
                        "start": 10,
                        "step": 1,
                        "stop": 11,
                        "width": 32,
                    },
                    "cmac_stat_rx_packet_1519_1522_bytes": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for good and bad packets received that contain 1519 to 1522 bytes.",
                        "start": 14,
                        "step": 1,
                        "stop": 15,
                        "width": 32,
                    },
                    "cmac_stat_rx_packet_1523_1548_bytes": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for good and bad packets received that contain 1523 to 1548 bytes.",
                        "start": 15,
                        "step": 1,
                        "stop": 16,
                        "width": 32,
                    },
                    "cmac_stat_rx_packet_1549_2047_bytes": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for good and bad packets received that contain 1549 to 2047 bytes.",
                        "start": 16,
                        "step": 1,
                        "stop": 17,
                        "width": 32,
                    },
                    "cmac_stat_rx_packet_2048_4095_bytes": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for good and bad packets received that contain 2048 to 4095 bytes.",
                        "start": 17,
                        "step": 1,
                        "stop": 18,
                        "width": 32,
                    },
                    "cmac_stat_rx_packet_256_511_bytes": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for good and bad packets received that contain 256 to 511 bytes.",
                        "start": 11,
                        "step": 1,
                        "stop": 12,
                        "width": 32,
                    },
                    "cmac_stat_rx_packet_4096_8191_bytes": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for good and bad packets received that contain 4096 to 8191 bytes.",
                        "start": 18,
                        "step": 1,
                        "stop": 19,
                        "width": 32,
                    },
                    "cmac_stat_rx_packet_512_1023_bytes": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for good and bad packets received that contain 512 to 1023 bytes.",
                        "start": 12,
                        "step": 1,
                        "stop": 13,
                        "width": 32,
                    },
                    "cmac_stat_rx_packet_64_bytes": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for good and bad packets received that contain 64 bytes.",
                        "start": 8,
                        "step": 1,
                        "stop": 9,
                        "width": 32,
                    },
                    "cmac_stat_rx_packet_65_127_bytes": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for good and bad packets received that contain 65 to 127 bytes.",
                        "start": 9,
                        "step": 1,
                        "stop": 10,
                        "width": 32,
                    },
                    "cmac_stat_rx_packet_8192_9215_bytes": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for good and bad packets received that contain 8192 to 9215 bytes.",
                        "start": 19,
                        "step": 1,
                        "stop": 20,
                        "width": 32,
                    },
                    "cmac_stat_rx_packet_bad_fcs": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for packets between 64 bytes and max length that have FCS errors.",
                        "start": 5,
                        "step": 1,
                        "stop": 6,
                        "width": 32,
                    },
                    "cmac_stat_rx_packet_large": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for packets more than 9215 bytes long.",
                        "start": 21,
                        "step": 1,
                        "stop": 22,
                        "width": 32,
                    },
                    "cmac_stat_rx_packet_small": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for packets less than 64 bytes long.",
                        "start": 20,
                        "step": 1,
                        "stop": 21,
                        "width": 32,
                    },
                    "cmac_stat_rx_stomped_fcs": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "A stomped FCS is defined as the bitwise inverse of the expected good FCS.",
                        "start": 6,
                        "step": 1,
                        "stop": 7,
                        "width": 32,
                    },
                    "cmac_stat_rx_toolong": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for packets longer than ctl_rx_max_packet_len with good and bad FCS.",
                        "start": 26,
                        "step": 1,
                        "stop": 27,
                        "width": 32,
                    },
                    "cmac_stat_rx_total_good_packets": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for total number of good packets, ie no errors.",
                        "start": 4,
                        "step": 1,
                        "stop": 5,
                        "width": 32,
                    },
                    "cmac_stat_rx_total_packets": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for total number of packets received.",
                        "start": 3,
                        "step": 1,
                        "stop": 4,
                        "width": 32,
                    },
                    "cmac_stat_rx_undersize": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for packets shorter than min packet length with good FCS.",
                        "start": 27,
                        "step": 1,
                        "stop": 28,
                        "width": 32,
                    },
                    "cmac_stat_rx_unicast": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for good unicast packets.",
                        "start": 22,
                        "step": 1,
                        "stop": 23,
                        "width": 32,
                    },
                    "cmac_stat_tx_total_good_packets": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for total number of good packets, ie no errors.",
                        "start": 2,
                        "step": 1,
                        "stop": 3,
                        "width": 32,
                    },
                    "cmac_stat_tx_total_packets": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for total number of packets received.",
                        "start": 1,
                        "step": 1,
                        "stop": 2,
                        "width": 32,
                    },
                },
                "start": 0,
                "step": 32,
                "stop": 32,
                "type": "REG",
            }
        },
        "start": 67584,
        "step": 32,
        "stop": 67616,
    },
    "drp": {
        "slaves": {
            "cmac_drp_interface": {
                "fields": {
                    "cmac_drp_addr_base": {
                        "access_mode": "RW",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Address to read from",
                        "start": 1,
                        "step": 1,
                        "stop": 2,
                        "width": 10,
                    },
                    "cmac_drp_return_value": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Data from DRP interface",
                        "start": 2,
                        "step": 1,
                        "stop": 3,
                        "width": 16,
                    },
                    "cmac_drp_sm_control_vector": {
                        "access_mode": "RW",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Definitions below, each action will take several cycles at 100MhZ, don't hammer!!!, Bit 0 - Perform Action, set 1, wait for DRP return value to update before de-asserting and setting up next "
                        "instruction Bit 1 - perform read = 0, write = 1 (performing a write will trigger a read to verify) ",
                        "start": 0,
                        "step": 1,
                        "stop": 1,
                        "width": 16,
                    },
                    "cmac_drp_value_to_write": {
                        "access_mode": "RW",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Data to write to DRP interface.",
                        "start": 3,
                        "step": 1,
                        "stop": 4,
                        "width": 16,
                    },
                    "cmac_stat_reset": {
                        "access_mode": "RW",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Clears all stat counters.",
                        "start": 15,
                        "step": 1,
                        "stop": 16,
                        "width": 8,
                    },
                    "cmac_stat_rx_bad_code": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for 64B/66B code violations.",
                        "start": 41,
                        "step": 1,
                        "stop": 42,
                        "width": 32,
                    },
                    "cmac_stat_rx_bad_preamble": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment bad preamble. Packet received was preceded by a invalid preamble.",
                        "start": 43,
                        "step": 1,
                        "stop": 44,
                        "width": 32,
                    },
                    "cmac_stat_rx_bad_sfd": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment bad SFD. Packet received was preceded by a invalid SFD.",
                        "start": 42,
                        "step": 1,
                        "stop": 43,
                        "width": 32,
                    },
                    "cmac_stat_rx_broadcast": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for good broadcast packets.",
                        "start": 36,
                        "step": 1,
                        "stop": 37,
                        "width": 32,
                    },
                    "cmac_stat_rx_fragment": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for packets shorter than min packet length with bad FCS.",
                        "start": 40,
                        "step": 1,
                        "stop": 41,
                        "width": 32,
                    },
                    "cmac_stat_rx_multicast": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for good multicast packets.",
                        "start": 35,
                        "step": 1,
                        "stop": 36,
                        "width": 32,
                    },
                    "cmac_stat_rx_oversize": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for packets longer than ctl_rx_max_packet_len with good FCS.",
                        "start": 37,
                        "step": 1,
                        "stop": 38,
                        "width": 32,
                    },
                    "cmac_stat_rx_packet_1024_1518_bytes": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for good and bad packets received that contain 1024 to 1518 bytes.",
                        "start": 25,
                        "step": 1,
                        "stop": 26,
                        "width": 32,
                    },
                    "cmac_stat_rx_packet_128_255_bytes": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for good and bad packets received that contain 128 to 255 bytes.",
                        "start": 22,
                        "step": 1,
                        "stop": 23,
                        "width": 32,
                    },
                    "cmac_stat_rx_packet_1519_1522_bytes": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for good and bad packets received that contain 1519 to 1522 bytes.",
                        "start": 26,
                        "step": 1,
                        "stop": 27,
                        "width": 32,
                    },
                    "cmac_stat_rx_packet_1523_1548_bytes": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for good and bad packets received that contain 1523 to 1548 bytes.",
                        "start": 27,
                        "step": 1,
                        "stop": 28,
                        "width": 32,
                    },
                    "cmac_stat_rx_packet_1549_2047_bytes": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for good and bad packets received that contain 1549 to 2047 bytes.",
                        "start": 28,
                        "step": 1,
                        "stop": 29,
                        "width": 32,
                    },
                    "cmac_stat_rx_packet_2048_4095_bytes": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for good and bad packets received that contain 2048 to 4095 bytes.",
                        "start": 29,
                        "step": 1,
                        "stop": 30,
                        "width": 32,
                    },
                    "cmac_stat_rx_packet_256_511_bytes": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for good and bad packets received that contain 256 to 511 bytes.",
                        "start": 23,
                        "step": 1,
                        "stop": 24,
                        "width": 32,
                    },
                    "cmac_stat_rx_packet_4096_8191_bytes": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for good and bad packets received that contain 4096 to 8191 bytes.",
                        "start": 30,
                        "step": 1,
                        "stop": 31,
                        "width": 32,
                    },
                    "cmac_stat_rx_packet_512_1023_bytes": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for good and bad packets received that contain 512 to 1023 bytes.",
                        "start": 24,
                        "step": 1,
                        "stop": 25,
                        "width": 32,
                    },
                    "cmac_stat_rx_packet_64_bytes": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for good and bad packets received that contain 64 bytes.",
                        "start": 20,
                        "step": 1,
                        "stop": 21,
                        "width": 32,
                    },
                    "cmac_stat_rx_packet_65_127_bytes": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for good and bad packets received that contain 65 to 127 bytes.",
                        "start": 21,
                        "step": 1,
                        "stop": 22,
                        "width": 32,
                    },
                    "cmac_stat_rx_packet_8192_9215_bytes": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for good and bad packets received that contain 8192 to 9215 bytes.",
                        "start": 31,
                        "step": 1,
                        "stop": 32,
                        "width": 32,
                    },
                    "cmac_stat_rx_packet_bad_fcs": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for packets between 64 and max length that have FCS errors.",
                        "start": 19,
                        "step": 1,
                        "stop": 20,
                        "width": 32,
                    },
                    "cmac_stat_rx_packet_large": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for packets more than 9215 bytes long.",
                        "start": 33,
                        "step": 1,
                        "stop": 34,
                        "width": 32,
                    },
                    "cmac_stat_rx_packet_small": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for packets less than 64 bytes long.",
                        "start": 32,
                        "step": 1,
                        "stop": 33,
                        "width": 32,
                    },
                    "cmac_stat_rx_toolong": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for packets longer than ctl_rx_max_packet_len with good and bad FCS.",
                        "start": 38,
                        "step": 1,
                        "stop": 39,
                        "width": 32,
                    },
                    "cmac_stat_rx_total_good_packets": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for total number of good packets, ie no errors.",
                        "start": 18,
                        "step": 1,
                        "stop": 19,
                        "width": 32,
                    },
                    "cmac_stat_rx_total_packets": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for total number of packets received.",
                        "start": 17,
                        "step": 1,
                        "stop": 18,
                        "width": 32,
                    },
                    "cmac_stat_rx_undersize": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for packets shorter than min packet length with good FCS.",
                        "start": 39,
                        "step": 1,
                        "stop": 40,
                        "width": 32,
                    },
                    "cmac_stat_rx_unicast": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for good unicast packets.",
                        "start": 34,
                        "step": 1,
                        "stop": 35,
                        "width": 32,
                    },
                    "cmac_stat_tx_total_packets": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for total number of packets received.",
                        "start": 16,
                        "step": 1,
                        "stop": 17,
                        "width": 32,
                    },
                    "gt_0_drp_return_value": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Data from DRP interface",
                        "start": 6,
                        "step": 1,
                        "stop": 7,
                        "width": 16,
                    },
                    "gt_0_drp_value_to_write": {
                        "access_mode": "RW",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Data to write to DRP interface.",
                        "start": 10,
                        "step": 1,
                        "stop": 11,
                        "width": 16,
                    },
                    "gt_1_drp_return_value": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Data from DRP interface",
                        "start": 7,
                        "step": 1,
                        "stop": 8,
                        "width": 16,
                    },
                    "gt_1_drp_value_to_write": {
                        "access_mode": "RW",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Data to write to DRP interface.",
                        "start": 11,
                        "step": 1,
                        "stop": 12,
                        "width": 16,
                    },
                    "gt_2_drp_return_value": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Data from DRP interface",
                        "start": 8,
                        "step": 1,
                        "stop": 9,
                        "width": 16,
                    },
                    "gt_2_drp_value_to_write": {
                        "access_mode": "RW",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Data to write to DRP interface.",
                        "start": 12,
                        "step": 1,
                        "stop": 13,
                        "width": 16,
                    },
                    "gt_3_drp_return_value": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Data from DRP interface",
                        "start": 9,
                        "step": 1,
                        "stop": 10,
                        "width": 16,
                    },
                    "gt_3_drp_value_to_write": {
                        "access_mode": "RW",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Data to write to DRP interface.",
                        "start": 13,
                        "step": 1,
                        "stop": 14,
                        "width": 16,
                    },
                    "gt_drp_addr_base": {
                        "access_mode": "RW",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Address to read from",
                        "start": 5,
                        "step": 1,
                        "stop": 6,
                        "width": 10,
                    },
                    "gt_drp_sm_control_vector": {
                        "access_mode": "RW",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Definitions below, each action will take several cycles at 100MhZ, don't hammer!!!, Bit 0 - Perform Action, set 1, wait for DRP return value to update before de-asserting and setting up next "
                        "instruction Bit 1 - GT lane 0 perform read = 0, write = 1 (performing a write will trigger a read to verify) Bit 2 - GT lane 1 perform read = 0, write = 1 (performing a write will trigger a read to "
                        "verify) Bit 3 - GT lane 2 perform read = 0, write = 1 (performing a write will trigger a read to verify) Bit 4 - GT lane 3 perform read = 0, write = 1 (performing a write will trigger a read to "
                        "verify) ",
                        "start": 4,
                        "step": 1,
                        "stop": 5,
                        "width": 16,
                    },
                    "rx_equaliser_settings": {
                        "access_mode": "RW",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Bit 0 is used to select between DFE and LPM settings, the next 7 bits can be used for Insertion loss figure.",
                        "start": 14,
                        "step": 1,
                        "stop": 15,
                        "width": 16,
                    },
                },
                "start": 0,
                "step": 44,
                "stop": 44,
                "type": "REG",
            }
        },
        "start": 66560,
        "step": 44,
        "stop": 66604,
    },
    "hbm_pktcontroller": {
        "slaves": {
            "config": {
                "fields": {
                    "axi_4k_finished": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "rd_fsm axi_4k_finished",
                        "start": 27,
                        "step": 1,
                        "stop": 28,
                        "width": 1,
                    },
                    "axi_rvalid_but_fifo_full": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "axi_rvalid_but_fifo_full",
                        "start": 30,
                        "step": 1,
                        "stop": 31,
                        "width": 1,
                    },
                    "beat_count": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "beat count in the current packet",
                        "start": 21,
                        "step": 1,
                        "stop": 22,
                        "width": 32,
                    },
                    "burst_count": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "current burst_count",
                        "start": 20,
                        "step": 1,
                        "stop": 21,
                        "width": 32,
                    },
                    "current_axi_4k_count": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "AXI 4k count ",
                        "start": 13,
                        "step": 1,
                        "stop": 14,
                        "width": 32,
                    },
                    "current_pkt_count_high": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "number of packets read out of fifo upper 32 bits of 64 bit counter",
                        "start": 24,
                        "step": 1,
                        "stop": 25,
                        "width": 32,
                    },
                    "current_pkt_count_low": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "number of packets read out of fifo upper 32 bits of 64 bit counter",
                        "start": 25,
                        "step": 1,
                        "stop": 26,
                        "width": 32,
                    },
                    "expected_beats_per_packet": {
                        "access_mode": "RW",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "expected_beats_per_packet",
                        "start": 17,
                        "step": 1,
                        "stop": 18,
                        "width": 32,
                    },
                    "expected_number_beats_per_burst": {
                        "access_mode": "RW",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "expected_number_beats_per_burst",
                        "start": 18,
                        "step": 1,
                        "stop": 19,
                        "width": 32,
                    },
                    "expected_number_of_loops": {
                        "access_mode": "RW",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Number of loops to do",
                        "start": 4,
                        "step": 1,
                        "stop": 5,
                        "width": 32,
                    },
                    "expected_packets_per_burst": {
                        "access_mode": "RW",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "expected_packets_per_burst",
                        "start": 15,
                        "step": 1,
                        "stop": 16,
                        "width": 32,
                    },
                    "expected_total_number_of_4k_axi": {
                        "access_mode": "RW",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "expected_total_number_of_4k_axi",
                        "start": 12,
                        "step": 1,
                        "stop": 13,
                        "width": 32,
                    },
                    "expected_total_number_of_bursts": {
                        "access_mode": "RW",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "expected_total_number_of_bursts",
                        "start": 16,
                        "step": 1,
                        "stop": 17,
                        "width": 32,
                    },
                    "fifo_full": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "fifo_full",
                        "start": 29,
                        "step": 1,
                        "stop": 30,
                        "width": 1,
                    },
                    "fifo_prog_full": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "fifo_prog_full",
                        "start": 28,
                        "step": 1,
                        "stop": 29,
                        "width": 1,
                    },
                    "fifo_rddatacount": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "FIFO_RdDataCount",
                        "start": 33,
                        "step": 1,
                        "stop": 34,
                        "width": 32,
                    },
                    "fifo_wrdatacount": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "FIFO_WrDataCount",
                        "start": 34,
                        "step": 1,
                        "stop": 35,
                        "width": 32,
                    },
                    "fpga_axi_beats_per_packet": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "FPGA calculated Number of AXI Beats_per_Packet calculated from the user supplied Packet_Size",
                        "start": 35,
                        "step": 1,
                        "stop": 36,
                        "width": 32,
                    },
                    "fpga_beat_in_burst_counter": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "fpga_beat_in_burst_counter",
                        "start": 19,
                        "step": 1,
                        "stop": 20,
                        "width": 32,
                    },
                    "fpga_pkt_count_in_this_burst": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "fpga_pkt_count_in_this_burst",
                        "start": 23,
                        "step": 1,
                        "stop": 24,
                        "width": 32,
                    },
                    "increase_header_frame_number": {
                        "access_mode": "RW",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "1 : Increase Frame Number",
                        "start": 7,
                        "step": 1,
                        "stop": 8,
                        "width": 1,
                    },
                    "inplace_header_update": {
                        "access_mode": "RW",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "0 : packetizer to insert Header. 1: packetizer to update in place of packet header fields)",
                        "start": 6,
                        "step": 1,
                        "stop": 7,
                        "width": 1,
                    },
                    "loop_cnt": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Loop Counter",
                        "start": 5,
                        "step": 1,
                        "stop": 6,
                        "width": 32,
                    },
                    "loop_tx": {
                        "access_mode": "RW",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "1: Loop traffic",
                        "start": 2,
                        "step": 1,
                        "stop": 3,
                        "width": 1,
                    },
                    "looping": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Looping is running",
                        "start": 3,
                        "step": 1,
                        "stop": 4,
                        "width": 1,
                    },
                    "ns_burst_timer": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "timer used to determine when to send the next burst of packets",
                        "start": 37,
                        "step": 1,
                        "stop": 38,
                        "width": 32,
                    },
                    "ns_total_time": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "current time since start of running in ns",
                        "start": 36,
                        "step": 1,
                        "stop": 37,
                        "width": 32,
                    },
                    "number_of_packets_in_burst": {
                        "access_mode": "RW",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Number of packets to send backtoback",
                        "start": 14,
                        "step": 1,
                        "stop": 15,
                        "width": 32,
                    },
                    "output_fsm_debug": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "output_fsm_debug",
                        "start": 32,
                        "step": 1,
                        "stop": 33,
                        "width": 32,
                    },
                    "packet_size": {
                        "access_mode": "RW",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "size of the complete packet including ethernet header, spead header etc",
                        "start": 9,
                        "step": 1,
                        "stop": 10,
                        "width": 32,
                    },
                    "packet_type": {
                        "access_mode": "RW",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "0 :RAW pcap (full ethernet packet), 2: SPEAD pcap, 3 CODIF pcap",
                        "start": 8,
                        "step": 1,
                        "stop": 9,
                        "width": 4,
                    },
                    "rd_fsm_debug": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "rd_fsm_debug",
                        "start": 31,
                        "step": 1,
                        "stop": 32,
                        "width": 32,
                    },
                    "running": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Is the HBM_PktController turn running",
                        "start": 1,
                        "step": 1,
                        "stop": 2,
                        "width": 1,
                    },
                    "start_stop_tx": {
                        "access_mode": "RW",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Start or stop the HBM_PktController.",
                        "start": 0,
                        "step": 1,
                        "stop": 1,
                        "width": 1,
                    },
                    "time_between_bursts_ns": {
                        "access_mode": "RW",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "time in ns",
                        "start": 11,
                        "step": 1,
                        "stop": 12,
                        "width": 32,
                    },
                    "total_beat_count": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Total Beat count",
                        "start": 22,
                        "step": 1,
                        "stop": 23,
                        "width": 32,
                    },
                    "total_number_tx_packets": {
                        "access_mode": "RW",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Total number of TX packets to play out",
                        "start": 10,
                        "step": 1,
                        "stop": 11,
                        "width": 32,
                    },
                    "total_pkts_to_mac_high": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "count of the total number of packets sent to the 100G MAC upper 32 bits of 64 bit counter",
                        "start": 38,
                        "step": 1,
                        "stop": 39,
                        "width": 32,
                    },
                    "total_pkts_to_mac_low": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "count of the total number of packets sent to the 100G MAC lower 32 bits of 64 bit counter",
                        "start": 39,
                        "step": 1,
                        "stop": 40,
                        "width": 32,
                    },
                    "tx_complete": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "tx_complete",
                        "start": 26,
                        "step": 1,
                        "stop": 27,
                        "width": 1,
                    },
                },
                "start": 0,
                "step": 40,
                "stop": 40,
                "type": "REG",
            }
        },
        "start": 65536,
        "step": 40,
        "stop": 65576,
    },
    "system": {
        "slaves": {
            "system": {
                "fields": {
                    "args_magic_number": {
                        "access_mode": "SP",
                        "bit_offset": 0,
                        "default": 4184502273,
                        "description": "args magic number for address 0",
                        "start": 0,
                        "step": 1,
                        "stop": 1,
                        "width": 32,
                    },
                    "args_map_build": {
                        "access_mode": "SP",
                        "bit_offset": 0,
                        "default": 570632468,
                        "description": "args map build date & hour",
                        "start": 1,
                        "step": 1,
                        "stop": 2,
                        "width": 32,
                    },
                    "build_date": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Build Date of firmware, Day/Month/Year, readable in HEX, hand coded and not tied to autogeneration currently",
                        "start": 4,
                        "step": 1,
                        "stop": 5,
                        "width": 32,
                    },
                    "eth100g_bytes_transmitted_hsec": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Half second of bytes sent",
                        "start": 17,
                        "step": 1,
                        "stop": 18,
                        "width": 32,
                    },
                    "eth100g_cycles_between_packets": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Largest number of idle cycles in the last half sec",
                        "start": 18,
                        "step": 1,
                        "stop": 19,
                        "width": 16,
                    },
                    "eth100g_fec_enable": {
                        "access_mode": "RW",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Set to 1 to enable FEC, 0 to disable",
                        "start": 16,
                        "step": 1,
                        "stop": 17,
                        "width": 1,
                    },
                    "eth100g_locked": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "100G ethernet is up",
                        "start": 11,
                        "step": 1,
                        "stop": 12,
                        "width": 1,
                    },
                    "eth100g_rx_bad_code": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Total packets received on the 100G ethernet with 64B/66B code violations",
                        "start": 14,
                        "step": 1,
                        "stop": 15,
                        "width": 32,
                    },
                    "eth100g_rx_bad_fcs": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Total packets received on the 100G ethernet with bad FCS since it was reset",
                        "start": 13,
                        "step": 1,
                        "stop": 14,
                        "width": 32,
                    },
                    "eth100g_rx_total_packets": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Total packets received on the 100G ethernet since it was reset",
                        "start": 12,
                        "step": 1,
                        "stop": 13,
                        "width": 32,
                    },
                    "eth100g_tx_total_packets": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Total packets sent on the 100G ethernet since it was reset",
                        "start": 15,
                        "step": 1,
                        "stop": 16,
                        "width": 32,
                    },
                    "firmware_label": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Firmware Label",
                        "start": 8,
                        "step": 1,
                        "stop": 9,
                        "width": 32,
                    },
                    "firmware_major_version": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Major version number",
                        "start": 5,
                        "step": 1,
                        "stop": 6,
                        "width": 16,
                    },
                    "firmware_minor_version": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Minor version number",
                        "start": 6,
                        "step": 1,
                        "stop": 7,
                        "width": 16,
                    },
                    "firmware_patch_version": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Patch version number",
                        "start": 7,
                        "step": 1,
                        "stop": 8,
                        "width": 16,
                    },
                    "firmware_personality": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Firmware function - PST/PSS/ZOOM/CORR",
                        "start": 9,
                        "step": 1,
                        "stop": 10,
                        "width": 32,
                    },
                    "qsfpgty_resets": {
                        "access_mode": "RW",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Reset 100G ethernet interface",
                        "start": 3,
                        "step": 1,
                        "stop": 4,
                        "width": 1,
                    },
                    "status_clocks_locked": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "All clocks locked",
                        "start": 2,
                        "step": 1,
                        "stop": 3,
                        "width": 1,
                    },
                    "time_uptime": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Number of seconds since programming",
                        "start": 10,
                        "step": 1,
                        "stop": 11,
                        "width": 32,
                    },
                },
                "start": 0,
                "step": 19,
                "stop": 19,
                "type": "REG",
            }
        },
        "start": 0,
        "step": 19,
        "stop": 19,
    },
    "timeslave": {
        "slaves": {
            "timeslave_scheduler": {
                "fields": {
                    "current_ptp_seconds_lower": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Live feed from hardware clock bits 63 -> 32 ... bit 32 = 1 sec",
                        "start": 1,
                        "step": 1,
                        "stop": 2,
                        "width": 32,
                    },
                    "current_ptp_seconds_upper": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Live feed from hardware clock 0x0000 & bits 79 -> 64 ... Upper 16 bits of 80 bit time vector, upper section of seconds.",
                        "start": 2,
                        "step": 1,
                        "stop": 3,
                        "width": 32,
                    },
                    "current_ptp_sub_seconds": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Live feed from hardware clock bits 31 -> 0 ... bit 31 = 1/2 sec, bit 30 = 1/4 sec and so on...",
                        "start": 0,
                        "step": 1,
                        "stop": 1,
                        "width": 32,
                    },
                    "schedule_control": {
                        "access_mode": "RW",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Multi bit control vector that will allow different operations of scheduled hardware actions. Assumes a valid future time has been set in the schedule_ptp_xxxx fields above. This register will be "
                        "polled and update the operations accordingly, will throttle update operations to every 1us. Bit 0 = reset logic to be scheduled, this will run a 100us reset pulse at the start of the run. Bit 1 = "
                        "start run. Bit 2 = end current run. ",
                        "start": 6,
                        "step": 1,
                        "stop": 7,
                        "width": 32,
                    },
                    "schedule_debug": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Feedback from hardware.. Bit 0 = Running state, 1 - running ... 0 - stopped Bit 1 = waiting to reach start time Bit 2 = past start time Bit 3 = error condition",
                        "start": 7,
                        "step": 1,
                        "stop": 8,
                        "width": 32,
                    },
                    "schedule_ptp_seconds_lower": {
                        "access_mode": "RW",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Target start time bits 63 -> 32 ... bit 32 = 1 sec",
                        "start": 4,
                        "step": 1,
                        "stop": 5,
                        "width": 32,
                    },
                    "schedule_ptp_seconds_upper": {
                        "access_mode": "RW",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Target start time 0x0000 & bits 79 -> 64 ... Upper 16 bits of 80 bit time vector, upper section of seconds.",
                        "start": 5,
                        "step": 1,
                        "stop": 6,
                        "width": 32,
                    },
                    "schedule_ptp_sub_seconds": {
                        "access_mode": "RW",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Target start time bits 31 -> 0 ... bit 31 = 1/2 sec, bit 30 = 1/4 sec and so on...",
                        "start": 3,
                        "step": 1,
                        "stop": 4,
                        "width": 32,
                    },
                },
                "start": 65536,
                "step": 8,
                "stop": 65544,
                "type": "REG",
            },
            "timeslave_space": {
                "fields": {
                    "data": {
                        "access_mode": "RW",
                        "bit_offset": 32,
                        "default": 0,
                        "description": " Shared memory space starts at 0x2_0000 and has range 32K Only some sections are valid refer to VHDL for map. Address space is used in 4 bytes. 0xdec0de1c is returned if the address space is not used. ",
                        "start": 0,
                        "step": 1,
                        "stop": 65536,
                        "width": 32,
                    }
                },
                "start": 0,
                "step": 65536,
                "stop": 65536,
                "type": "RAM",
            },
        },
        "start": 131072,
        "step": 65544,
        "stop": 196616,
    },
    "vitis_shared": {
        "slaves": {
            "vitis_shared": {
                "fields": {
                    "data": {
                        "access_mode": "RW",
                        "bit_offset": 32,
                        "default": 0,
                        "description": "128 Kbyte page to access the registers. Copy data to/from this memory using the CDMA core.",
                        "start": 0,
                        "step": 1,
                        "stop": 32768,
                        "width": 32,
                    }
                },
                "start": 0,
                "step": 32768,
                "stop": 32768,
                "type": "RAM",
            }
        },
        "start": 32768,
        "step": 32768,
        "stop": 65536,
    },
}
