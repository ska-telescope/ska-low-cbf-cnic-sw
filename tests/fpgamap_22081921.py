# M&C Python client include file for cnic FPGA
# Note that this file uses register (not AXI byte) addresses and offsets
FPGAMAP = {
    "cmac": {
        "slaves": {
            "cmac_stats_interface": {
                "fields": {
                    "cmac_100g_locked": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "100G ethernet is up",
                        "start": 0,
                        "step": 1,
                        "stop": 1,
                        "width": 1,
                    },
                    "cmac_reset": {
                        "access_mode": "RW",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Reset CMAC HARD IP and GTs",
                        "start": 1,
                        "step": 1,
                        "stop": 2,
                        "width": 1,
                    },
                    "cmac_stat_reset": {
                        "access_mode": "RW",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Clears all stat counters. Set bit[0] to 1, this will trigger a reset process, this register will still need to set back to 0.",
                        "start": 2,
                        "step": 1,
                        "stop": 3,
                        "width": 8,
                    },
                    "cmac_stat_rx_bad_code": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for 64B/66B code violations.",
                        "start": 31,
                        "step": 1,
                        "stop": 32,
                        "width": 32,
                    },
                    "cmac_stat_rx_bad_fcs": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "A packet was received with a bad FCS but not a stomped FCS.",
                        "start": 9,
                        "step": 1,
                        "stop": 10,
                        "width": 32,
                    },
                    "cmac_stat_rx_bad_preamble": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment bad preamble. Packet received was preceded by a invalid preamble.",
                        "start": 33,
                        "step": 1,
                        "stop": 34,
                        "width": 32,
                    },
                    "cmac_stat_rx_bad_sfd": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment bad SFD. Packet received was preceded by a invalid SFD.",
                        "start": 32,
                        "step": 1,
                        "stop": 33,
                        "width": 32,
                    },
                    "cmac_stat_rx_broadcast": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for good broadcast packets.",
                        "start": 26,
                        "step": 1,
                        "stop": 27,
                        "width": 32,
                    },
                    "cmac_stat_rx_fragment": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for packets shorter than min packet length with bad FCS.",
                        "start": 30,
                        "step": 1,
                        "stop": 31,
                        "width": 32,
                    },
                    "cmac_stat_rx_multicast": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for good multicast packets.",
                        "start": 25,
                        "step": 1,
                        "stop": 26,
                        "width": 32,
                    },
                    "cmac_stat_rx_oversize": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for packets longer than ctl_rx_max_packet_len with good FCS.",
                        "start": 27,
                        "step": 1,
                        "stop": 28,
                        "width": 32,
                    },
                    "cmac_stat_rx_packet_1024_1518_bytes": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for good and bad packets received that contain 1024 to 1518 bytes.",
                        "start": 15,
                        "step": 1,
                        "stop": 16,
                        "width": 32,
                    },
                    "cmac_stat_rx_packet_128_255_bytes": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for good and bad packets received that contain 128 to 255 bytes.",
                        "start": 12,
                        "step": 1,
                        "stop": 13,
                        "width": 32,
                    },
                    "cmac_stat_rx_packet_1519_1522_bytes": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for good and bad packets received that contain 1519 to 1522 bytes.",
                        "start": 16,
                        "step": 1,
                        "stop": 17,
                        "width": 32,
                    },
                    "cmac_stat_rx_packet_1523_1548_bytes": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for good and bad packets received that contain 1523 to 1548 bytes.",
                        "start": 17,
                        "step": 1,
                        "stop": 18,
                        "width": 32,
                    },
                    "cmac_stat_rx_packet_1549_2047_bytes": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for good and bad packets received that contain 1549 to 2047 bytes.",
                        "start": 18,
                        "step": 1,
                        "stop": 19,
                        "width": 32,
                    },
                    "cmac_stat_rx_packet_2048_4095_bytes": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for good and bad packets received that contain 2048 to 4095 bytes.",
                        "start": 19,
                        "step": 1,
                        "stop": 20,
                        "width": 32,
                    },
                    "cmac_stat_rx_packet_256_511_bytes": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for good and bad packets received that contain 256 to 511 bytes.",
                        "start": 13,
                        "step": 1,
                        "stop": 14,
                        "width": 32,
                    },
                    "cmac_stat_rx_packet_4096_8191_bytes": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for good and bad packets received that contain 4096 to 8191 bytes.",
                        "start": 20,
                        "step": 1,
                        "stop": 21,
                        "width": 32,
                    },
                    "cmac_stat_rx_packet_512_1023_bytes": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for good and bad packets received that contain 512 to 1023 bytes.",
                        "start": 14,
                        "step": 1,
                        "stop": 15,
                        "width": 32,
                    },
                    "cmac_stat_rx_packet_64_bytes": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for good and bad packets received that contain 64 bytes.",
                        "start": 10,
                        "step": 1,
                        "stop": 11,
                        "width": 32,
                    },
                    "cmac_stat_rx_packet_65_127_bytes": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for good and bad packets received that contain 65 to 127 bytes.",
                        "start": 11,
                        "step": 1,
                        "stop": 12,
                        "width": 32,
                    },
                    "cmac_stat_rx_packet_8192_9215_bytes": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for good and bad packets received that contain 8192 to 9215 bytes.",
                        "start": 21,
                        "step": 1,
                        "stop": 22,
                        "width": 32,
                    },
                    "cmac_stat_rx_packet_bad_fcs": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for packets between 64 bytes and max length that have FCS errors.",
                        "start": 7,
                        "step": 1,
                        "stop": 8,
                        "width": 32,
                    },
                    "cmac_stat_rx_packet_large": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for packets more than 9215 bytes long.",
                        "start": 23,
                        "step": 1,
                        "stop": 24,
                        "width": 32,
                    },
                    "cmac_stat_rx_packet_small": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for packets less than 64 bytes long.",
                        "start": 22,
                        "step": 1,
                        "stop": 23,
                        "width": 32,
                    },
                    "cmac_stat_rx_stomped_fcs": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "A stomped FCS is defined as the bitwise inverse of the expected good FCS.",
                        "start": 8,
                        "step": 1,
                        "stop": 9,
                        "width": 32,
                    },
                    "cmac_stat_rx_toolong": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for packets longer than ctl_rx_max_packet_len with good and bad FCS.",
                        "start": 28,
                        "step": 1,
                        "stop": 29,
                        "width": 32,
                    },
                    "cmac_stat_rx_total_good_packets": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for total number of good packets, ie no errors.",
                        "start": 6,
                        "step": 1,
                        "stop": 7,
                        "width": 32,
                    },
                    "cmac_stat_rx_total_packets": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for total number of packets received.",
                        "start": 5,
                        "step": 1,
                        "stop": 6,
                        "width": 32,
                    },
                    "cmac_stat_rx_undersize": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for packets shorter than min packet length with good FCS.",
                        "start": 29,
                        "step": 1,
                        "stop": 30,
                        "width": 32,
                    },
                    "cmac_stat_rx_unicast": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for good unicast packets.",
                        "start": 24,
                        "step": 1,
                        "stop": 25,
                        "width": 32,
                    },
                    "cmac_stat_tx_total_good_packets": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for total number of good packets, ie no errors.",
                        "start": 4,
                        "step": 1,
                        "stop": 5,
                        "width": 32,
                    },
                    "cmac_stat_tx_total_packets": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for total number of packets received.",
                        "start": 3,
                        "step": 1,
                        "stop": 4,
                        "width": 32,
                    },
                },
                "start": 0,
                "step": 34,
                "stop": 34,
                "type": "REG",
            }
        },
        "start": 67584,
        "step": 34,
        "stop": 67618,
    },
    "cmac_b": {
        "slaves": {
            "cmac_stats_interface": {
                "fields": {
                    "cmac_100g_locked": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "100G ethernet is up",
                        "start": 0,
                        "step": 1,
                        "stop": 1,
                        "width": 1,
                    },
                    "cmac_reset": {
                        "access_mode": "RW",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Reset CMAC HARD IP and GTs",
                        "start": 1,
                        "step": 1,
                        "stop": 2,
                        "width": 1,
                    },
                    "cmac_stat_reset": {
                        "access_mode": "RW",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Clears all stat counters. Set bit[0] to 1, this will trigger a reset process, this register will still need to set back to 0.",
                        "start": 2,
                        "step": 1,
                        "stop": 3,
                        "width": 8,
                    },
                    "cmac_stat_rx_bad_code": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for 64B/66B code violations.",
                        "start": 31,
                        "step": 1,
                        "stop": 32,
                        "width": 32,
                    },
                    "cmac_stat_rx_bad_fcs": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "A packet was received with a bad FCS but not a stomped FCS.",
                        "start": 9,
                        "step": 1,
                        "stop": 10,
                        "width": 32,
                    },
                    "cmac_stat_rx_bad_preamble": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment bad preamble. Packet received was preceded by a invalid preamble.",
                        "start": 33,
                        "step": 1,
                        "stop": 34,
                        "width": 32,
                    },
                    "cmac_stat_rx_bad_sfd": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment bad SFD. Packet received was preceded by a invalid SFD.",
                        "start": 32,
                        "step": 1,
                        "stop": 33,
                        "width": 32,
                    },
                    "cmac_stat_rx_broadcast": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for good broadcast packets.",
                        "start": 26,
                        "step": 1,
                        "stop": 27,
                        "width": 32,
                    },
                    "cmac_stat_rx_fragment": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for packets shorter than min packet length with bad FCS.",
                        "start": 30,
                        "step": 1,
                        "stop": 31,
                        "width": 32,
                    },
                    "cmac_stat_rx_multicast": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for good multicast packets.",
                        "start": 25,
                        "step": 1,
                        "stop": 26,
                        "width": 32,
                    },
                    "cmac_stat_rx_oversize": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for packets longer than ctl_rx_max_packet_len with good FCS.",
                        "start": 27,
                        "step": 1,
                        "stop": 28,
                        "width": 32,
                    },
                    "cmac_stat_rx_packet_1024_1518_bytes": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for good and bad packets received that contain 1024 to 1518 bytes.",
                        "start": 15,
                        "step": 1,
                        "stop": 16,
                        "width": 32,
                    },
                    "cmac_stat_rx_packet_128_255_bytes": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for good and bad packets received that contain 128 to 255 bytes.",
                        "start": 12,
                        "step": 1,
                        "stop": 13,
                        "width": 32,
                    },
                    "cmac_stat_rx_packet_1519_1522_bytes": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for good and bad packets received that contain 1519 to 1522 bytes.",
                        "start": 16,
                        "step": 1,
                        "stop": 17,
                        "width": 32,
                    },
                    "cmac_stat_rx_packet_1523_1548_bytes": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for good and bad packets received that contain 1523 to 1548 bytes.",
                        "start": 17,
                        "step": 1,
                        "stop": 18,
                        "width": 32,
                    },
                    "cmac_stat_rx_packet_1549_2047_bytes": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for good and bad packets received that contain 1549 to 2047 bytes.",
                        "start": 18,
                        "step": 1,
                        "stop": 19,
                        "width": 32,
                    },
                    "cmac_stat_rx_packet_2048_4095_bytes": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for good and bad packets received that contain 2048 to 4095 bytes.",
                        "start": 19,
                        "step": 1,
                        "stop": 20,
                        "width": 32,
                    },
                    "cmac_stat_rx_packet_256_511_bytes": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for good and bad packets received that contain 256 to 511 bytes.",
                        "start": 13,
                        "step": 1,
                        "stop": 14,
                        "width": 32,
                    },
                    "cmac_stat_rx_packet_4096_8191_bytes": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for good and bad packets received that contain 4096 to 8191 bytes.",
                        "start": 20,
                        "step": 1,
                        "stop": 21,
                        "width": 32,
                    },
                    "cmac_stat_rx_packet_512_1023_bytes": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for good and bad packets received that contain 512 to 1023 bytes.",
                        "start": 14,
                        "step": 1,
                        "stop": 15,
                        "width": 32,
                    },
                    "cmac_stat_rx_packet_64_bytes": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for good and bad packets received that contain 64 bytes.",
                        "start": 10,
                        "step": 1,
                        "stop": 11,
                        "width": 32,
                    },
                    "cmac_stat_rx_packet_65_127_bytes": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for good and bad packets received that contain 65 to 127 bytes.",
                        "start": 11,
                        "step": 1,
                        "stop": 12,
                        "width": 32,
                    },
                    "cmac_stat_rx_packet_8192_9215_bytes": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for good and bad packets received that contain 8192 to 9215 bytes.",
                        "start": 21,
                        "step": 1,
                        "stop": 22,
                        "width": 32,
                    },
                    "cmac_stat_rx_packet_bad_fcs": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for packets between 64 bytes and max length that have FCS errors.",
                        "start": 7,
                        "step": 1,
                        "stop": 8,
                        "width": 32,
                    },
                    "cmac_stat_rx_packet_large": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for packets more than 9215 bytes long.",
                        "start": 23,
                        "step": 1,
                        "stop": 24,
                        "width": 32,
                    },
                    "cmac_stat_rx_packet_small": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for packets less than 64 bytes long.",
                        "start": 22,
                        "step": 1,
                        "stop": 23,
                        "width": 32,
                    },
                    "cmac_stat_rx_stomped_fcs": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "A stomped FCS is defined as the bitwise inverse of the expected good FCS.",
                        "start": 8,
                        "step": 1,
                        "stop": 9,
                        "width": 32,
                    },
                    "cmac_stat_rx_toolong": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for packets longer than ctl_rx_max_packet_len with good and bad FCS.",
                        "start": 28,
                        "step": 1,
                        "stop": 29,
                        "width": 32,
                    },
                    "cmac_stat_rx_total_good_packets": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for total number of good packets, ie no errors.",
                        "start": 6,
                        "step": 1,
                        "stop": 7,
                        "width": 32,
                    },
                    "cmac_stat_rx_total_packets": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for total number of packets received.",
                        "start": 5,
                        "step": 1,
                        "stop": 6,
                        "width": 32,
                    },
                    "cmac_stat_rx_undersize": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for packets shorter than min packet length with good FCS.",
                        "start": 29,
                        "step": 1,
                        "stop": 30,
                        "width": 32,
                    },
                    "cmac_stat_rx_unicast": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for good unicast packets.",
                        "start": 24,
                        "step": 1,
                        "stop": 25,
                        "width": 32,
                    },
                    "cmac_stat_tx_total_good_packets": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for total number of good packets, ie no errors.",
                        "start": 4,
                        "step": 1,
                        "stop": 5,
                        "width": 32,
                    },
                    "cmac_stat_tx_total_packets": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for total number of packets received.",
                        "start": 3,
                        "step": 1,
                        "stop": 4,
                        "width": 32,
                    },
                },
                "start": 0,
                "step": 34,
                "stop": 34,
                "type": "REG",
            }
        },
        "start": 197632,
        "step": 34,
        "stop": 197666,
    },
    "drp": {
        "slaves": {
            "cmac_drp_interface": {
                "fields": {
                    "cmac_drp_addr_base": {
                        "access_mode": "RW",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Address to read from",
                        "start": 1,
                        "step": 1,
                        "stop": 2,
                        "width": 10,
                    },
                    "cmac_drp_return_value": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Data from DRP interface",
                        "start": 2,
                        "step": 1,
                        "stop": 3,
                        "width": 16,
                    },
                    "cmac_drp_sm_control_vector": {
                        "access_mode": "RW",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Definitions below, each action will take several cycles at 100MhZ, don't hammer!!!, Bit 0 - Perform Action, set 1, wait for DRP return value to update before de-asserting and setting up next "
                        "instruction Bit 1 - perform read = 0, write = 1 (performing a write will trigger a read to verify) ",
                        "start": 0,
                        "step": 1,
                        "stop": 1,
                        "width": 16,
                    },
                    "cmac_drp_value_to_write": {
                        "access_mode": "RW",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Data to write to DRP interface.",
                        "start": 3,
                        "step": 1,
                        "stop": 4,
                        "width": 16,
                    },
                    "cmac_stat_reset": {
                        "access_mode": "RW",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Clears all stat counters.",
                        "start": 15,
                        "step": 1,
                        "stop": 16,
                        "width": 8,
                    },
                    "cmac_stat_rx_bad_code": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for 64B/66B code violations.",
                        "start": 41,
                        "step": 1,
                        "stop": 42,
                        "width": 32,
                    },
                    "cmac_stat_rx_bad_preamble": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment bad preamble. Packet received was preceded by a invalid preamble.",
                        "start": 43,
                        "step": 1,
                        "stop": 44,
                        "width": 32,
                    },
                    "cmac_stat_rx_bad_sfd": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment bad SFD. Packet received was preceded by a invalid SFD.",
                        "start": 42,
                        "step": 1,
                        "stop": 43,
                        "width": 32,
                    },
                    "cmac_stat_rx_broadcast": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for good broadcast packets.",
                        "start": 36,
                        "step": 1,
                        "stop": 37,
                        "width": 32,
                    },
                    "cmac_stat_rx_fragment": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for packets shorter than min packet length with bad FCS.",
                        "start": 40,
                        "step": 1,
                        "stop": 41,
                        "width": 32,
                    },
                    "cmac_stat_rx_multicast": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for good multicast packets.",
                        "start": 35,
                        "step": 1,
                        "stop": 36,
                        "width": 32,
                    },
                    "cmac_stat_rx_oversize": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for packets longer than ctl_rx_max_packet_len with good FCS.",
                        "start": 37,
                        "step": 1,
                        "stop": 38,
                        "width": 32,
                    },
                    "cmac_stat_rx_packet_1024_1518_bytes": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for good and bad packets received that contain 1024 to 1518 bytes.",
                        "start": 25,
                        "step": 1,
                        "stop": 26,
                        "width": 32,
                    },
                    "cmac_stat_rx_packet_128_255_bytes": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for good and bad packets received that contain 128 to 255 bytes.",
                        "start": 22,
                        "step": 1,
                        "stop": 23,
                        "width": 32,
                    },
                    "cmac_stat_rx_packet_1519_1522_bytes": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for good and bad packets received that contain 1519 to 1522 bytes.",
                        "start": 26,
                        "step": 1,
                        "stop": 27,
                        "width": 32,
                    },
                    "cmac_stat_rx_packet_1523_1548_bytes": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for good and bad packets received that contain 1523 to 1548 bytes.",
                        "start": 27,
                        "step": 1,
                        "stop": 28,
                        "width": 32,
                    },
                    "cmac_stat_rx_packet_1549_2047_bytes": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for good and bad packets received that contain 1549 to 2047 bytes.",
                        "start": 28,
                        "step": 1,
                        "stop": 29,
                        "width": 32,
                    },
                    "cmac_stat_rx_packet_2048_4095_bytes": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for good and bad packets received that contain 2048 to 4095 bytes.",
                        "start": 29,
                        "step": 1,
                        "stop": 30,
                        "width": 32,
                    },
                    "cmac_stat_rx_packet_256_511_bytes": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for good and bad packets received that contain 256 to 511 bytes.",
                        "start": 23,
                        "step": 1,
                        "stop": 24,
                        "width": 32,
                    },
                    "cmac_stat_rx_packet_4096_8191_bytes": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for good and bad packets received that contain 4096 to 8191 bytes.",
                        "start": 30,
                        "step": 1,
                        "stop": 31,
                        "width": 32,
                    },
                    "cmac_stat_rx_packet_512_1023_bytes": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for good and bad packets received that contain 512 to 1023 bytes.",
                        "start": 24,
                        "step": 1,
                        "stop": 25,
                        "width": 32,
                    },
                    "cmac_stat_rx_packet_64_bytes": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for good and bad packets received that contain 64 bytes.",
                        "start": 20,
                        "step": 1,
                        "stop": 21,
                        "width": 32,
                    },
                    "cmac_stat_rx_packet_65_127_bytes": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for good and bad packets received that contain 65 to 127 bytes.",
                        "start": 21,
                        "step": 1,
                        "stop": 22,
                        "width": 32,
                    },
                    "cmac_stat_rx_packet_8192_9215_bytes": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for good and bad packets received that contain 8192 to 9215 bytes.",
                        "start": 31,
                        "step": 1,
                        "stop": 32,
                        "width": 32,
                    },
                    "cmac_stat_rx_packet_bad_fcs": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for packets between 64 and max length that have FCS errors.",
                        "start": 19,
                        "step": 1,
                        "stop": 20,
                        "width": 32,
                    },
                    "cmac_stat_rx_packet_large": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for packets more than 9215 bytes long.",
                        "start": 33,
                        "step": 1,
                        "stop": 34,
                        "width": 32,
                    },
                    "cmac_stat_rx_packet_small": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for packets less than 64 bytes long.",
                        "start": 32,
                        "step": 1,
                        "stop": 33,
                        "width": 32,
                    },
                    "cmac_stat_rx_toolong": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for packets longer than ctl_rx_max_packet_len with good and bad FCS.",
                        "start": 38,
                        "step": 1,
                        "stop": 39,
                        "width": 32,
                    },
                    "cmac_stat_rx_total_good_packets": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for total number of good packets, ie no errors.",
                        "start": 18,
                        "step": 1,
                        "stop": 19,
                        "width": 32,
                    },
                    "cmac_stat_rx_total_packets": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for total number of packets received.",
                        "start": 17,
                        "step": 1,
                        "stop": 18,
                        "width": 32,
                    },
                    "cmac_stat_rx_undersize": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for packets shorter than min packet length with good FCS.",
                        "start": 39,
                        "step": 1,
                        "stop": 40,
                        "width": 32,
                    },
                    "cmac_stat_rx_unicast": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for good unicast packets.",
                        "start": 34,
                        "step": 1,
                        "stop": 35,
                        "width": 32,
                    },
                    "cmac_stat_tx_total_packets": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Increment for total number of packets received.",
                        "start": 16,
                        "step": 1,
                        "stop": 17,
                        "width": 32,
                    },
                    "gt_0_drp_return_value": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Data from DRP interface",
                        "start": 6,
                        "step": 1,
                        "stop": 7,
                        "width": 16,
                    },
                    "gt_0_drp_value_to_write": {
                        "access_mode": "RW",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Data to write to DRP interface.",
                        "start": 10,
                        "step": 1,
                        "stop": 11,
                        "width": 16,
                    },
                    "gt_1_drp_return_value": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Data from DRP interface",
                        "start": 7,
                        "step": 1,
                        "stop": 8,
                        "width": 16,
                    },
                    "gt_1_drp_value_to_write": {
                        "access_mode": "RW",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Data to write to DRP interface.",
                        "start": 11,
                        "step": 1,
                        "stop": 12,
                        "width": 16,
                    },
                    "gt_2_drp_return_value": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Data from DRP interface",
                        "start": 8,
                        "step": 1,
                        "stop": 9,
                        "width": 16,
                    },
                    "gt_2_drp_value_to_write": {
                        "access_mode": "RW",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Data to write to DRP interface.",
                        "start": 12,
                        "step": 1,
                        "stop": 13,
                        "width": 16,
                    },
                    "gt_3_drp_return_value": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Data from DRP interface",
                        "start": 9,
                        "step": 1,
                        "stop": 10,
                        "width": 16,
                    },
                    "gt_3_drp_value_to_write": {
                        "access_mode": "RW",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Data to write to DRP interface.",
                        "start": 13,
                        "step": 1,
                        "stop": 14,
                        "width": 16,
                    },
                    "gt_drp_addr_base": {
                        "access_mode": "RW",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Address to read from",
                        "start": 5,
                        "step": 1,
                        "stop": 6,
                        "width": 10,
                    },
                    "gt_drp_sm_control_vector": {
                        "access_mode": "RW",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Definitions below, each action will take several cycles at 100MhZ, don't hammer!!!, Bit 0 - Perform Action, set 1, wait for DRP return value to update before de-asserting and setting up next "
                        "instruction Bit 1 - GT lane 0 perform read = 0, write = 1 (performing a write will trigger a read to verify) Bit 2 - GT lane 1 perform read = 0, write = 1 (performing a write will trigger a read to "
                        "verify) Bit 3 - GT lane 2 perform read = 0, write = 1 (performing a write will trigger a read to verify) Bit 4 - GT lane 3 perform read = 0, write = 1 (performing a write will trigger a read to "
                        "verify) ",
                        "start": 4,
                        "step": 1,
                        "stop": 5,
                        "width": 16,
                    },
                    "rx_equaliser_settings": {
                        "access_mode": "RW",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Bit 0 is used to select between DFE and LPM settings, the next 7 bits can be used for Insertion loss figure.",
                        "start": 14,
                        "step": 1,
                        "stop": 15,
                        "width": 16,
                    },
                },
                "start": 0,
                "step": 44,
                "stop": 44,
                "type": "REG",
            }
        },
        "start": 66560,
        "step": 44,
        "stop": 66604,
    },
    "hbm_pktcontroller": {
        "slaves": {
            "config": {
                "fields": {
                    "debug_fifo_datacount": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Read and Write counts from the FIFO cache in HBM controller holding the data from HBM before sending to CMAC",
                        "start": 35,
                        "step": 1,
                        "stop": 36,
                        "width": 32,
                    },
                    "debug_input_fsm_debug": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "input_fsm_debug, the current state of the RX StateMachine between data from CMAC and HBM",
                        "start": 34,
                        "step": 1,
                        "stop": 35,
                        "width": 32,
                    },
                    "debug_output_fsm_debug": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "output_fsm_debug, the current state of the Send packet to 100G StateMachine",
                        "start": 33,
                        "step": 1,
                        "stop": 34,
                        "width": 32,
                    },
                    "debug_rd_fsm_debug": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "rd_fsm_debug, the current state of the RD request to HBM StateMachine",
                        "start": 32,
                        "step": 1,
                        "stop": 33,
                        "width": 32,
                    },
                    "debug_tx_burst_packet_count": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "current count in a burst",
                        "start": 31,
                        "step": 1,
                        "stop": 32,
                        "width": 32,
                    },
                    "debug_tx_current_hbm_rd_addr": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "current_hbm_rd_addr",
                        "start": 27,
                        "step": 1,
                        "stop": 28,
                        "width": 32,
                    },
                    "debug_tx_current_hbm_rd_buffer": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "current HBM bank, 0 1 2 or 3",
                        "start": 28,
                        "step": 1,
                        "stop": 29,
                        "width": 32,
                    },
                    "debug_tx_packet_beat_count": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "How many rd signals the current packet sending, to the FIFO sending to packet_player",
                        "start": 30,
                        "step": 1,
                        "stop": 31,
                        "width": 32,
                    },
                    "debug_tx_total_packet_beat_count": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Total rd signals sent to FIFO sending to packet_player",
                        "start": 29,
                        "step": 1,
                        "stop": 30,
                        "width": 32,
                    },
                    "ns_burst_timer": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "timer used to determine when to send the next burst of packets",
                        "start": 37,
                        "step": 1,
                        "stop": 38,
                        "width": 32,
                    },
                    "ns_total_time": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "current time since start of running in ns",
                        "start": 36,
                        "step": 1,
                        "stop": 37,
                        "width": 32,
                    },
                    "rx_complete": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "capture full",
                        "start": 47,
                        "step": 1,
                        "stop": 48,
                        "width": 1,
                    },
                    "rx_enable_capture": {
                        "access_mode": "RW",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "rx capture logic enable",
                        "start": 41,
                        "step": 1,
                        "stop": 42,
                        "width": 1,
                    },
                    "rx_hbm_1_end_addr": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "HBM #1 end of data address",
                        "start": 42,
                        "step": 1,
                        "stop": 43,
                        "width": 32,
                    },
                    "rx_hbm_2_end_addr": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "HBM #2 end of data address",
                        "start": 43,
                        "step": 1,
                        "stop": 44,
                        "width": 32,
                    },
                    "rx_hbm_3_end_addr": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "HBM #3 end of data address",
                        "start": 44,
                        "step": 1,
                        "stop": 45,
                        "width": 32,
                    },
                    "rx_hbm_4_end_addr": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "HBM #4 end of data address",
                        "start": 45,
                        "step": 1,
                        "stop": 46,
                        "width": 32,
                    },
                    "rx_packet_count_hi": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Total number of captured packets upper 32 bits of 64",
                        "start": 48,
                        "step": 1,
                        "stop": 49,
                        "width": 32,
                    },
                    "rx_packet_count_lo": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Total number of captured packets lower 32 bits of 64",
                        "start": 49,
                        "step": 1,
                        "stop": 50,
                        "width": 32,
                    },
                    "rx_packet_size": {
                        "access_mode": "RW",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "byte count of packet we want to capture",
                        "start": 38,
                        "step": 1,
                        "stop": 39,
                        "width": 32,
                    },
                    "rx_packets_to_capture": {
                        "access_mode": "RW",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Number of packets to capture before stopping.",
                        "start": 46,
                        "step": 1,
                        "stop": 47,
                        "width": 32,
                    },
                    "rx_reset_capture": {
                        "access_mode": "RW",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "reset capture logic chain",
                        "start": 39,
                        "step": 1,
                        "stop": 40,
                        "width": 1,
                    },
                    "rx_reset_counter": {
                        "access_mode": "RW",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "reset capture logic stats",
                        "start": 40,
                        "step": 1,
                        "stop": 41,
                        "width": 1,
                    },
                    "tx_axi_transaction_count": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "current number of AXI transactions for tx since reset",
                        "start": 15,
                        "step": 1,
                        "stop": 16,
                        "width": 32,
                    },
                    "tx_axi_transactions": {
                        "access_mode": "RW",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Total number of HBM RDs required = tx_total_number_TX_packets x (ceil(tx_packet_size/64))",
                        "start": 14,
                        "step": 1,
                        "stop": 15,
                        "width": 32,
                    },
                    "tx_beats_per_burst": {
                        "access_mode": "RW",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "From above will be 1 x tx_beats_per_packet",
                        "start": 20,
                        "step": 1,
                        "stop": 21,
                        "width": 32,
                    },
                    "tx_beats_per_packet": {
                        "access_mode": "RW",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Beat is an AXI transfer (512 bit width), number of beats per packet = tx_packet_size / 64",
                        "start": 19,
                        "step": 1,
                        "stop": 20,
                        "width": 32,
                    },
                    "tx_burst_count": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "current burst_count value, ie progress to tx_bursts",
                        "start": 21,
                        "step": 1,
                        "stop": 22,
                        "width": 32,
                    },
                    "tx_burst_gap": {
                        "access_mode": "RW",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "time in ns between start of packets",
                        "start": 13,
                        "step": 1,
                        "stop": 14,
                        "width": 32,
                    },
                    "tx_burst_packets": {
                        "access_mode": "RW",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Number of packets to send back-to-back",
                        "start": 16,
                        "step": 1,
                        "stop": 17,
                        "width": 32,
                    },
                    "tx_bursts": {
                        "access_mode": "RW",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "From above this will be (tx_total_number_TX_packets / packets per burst), so current will also = tx_total_number_TX_packets ",
                        "start": 18,
                        "step": 1,
                        "stop": 19,
                        "width": 32,
                    },
                    "tx_codif_header_frame_initial_value": {
                        "access_mode": "RW",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "frame_initial_value",
                        "start": 9,
                        "step": 1,
                        "stop": 10,
                        "width": 32,
                    },
                    "tx_codif_header_packets_epoch_offset": {
                        "access_mode": "RW",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "For example, set to 27 for CODIF",
                        "start": 8,
                        "step": 1,
                        "stop": 9,
                        "width": 32,
                    },
                    "tx_codif_header_packets_per_frame": {
                        "access_mode": "RW",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "For updating the counters this is (number of jimbles * channels) parameter",
                        "start": 7,
                        "step": 1,
                        "stop": 8,
                        "width": 32,
                    },
                    "tx_complete": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "tx_complete",
                        "start": 26,
                        "step": 1,
                        "stop": 27,
                        "width": 1,
                    },
                    "tx_enable": {
                        "access_mode": "RW",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Start or stop the HBM_PktController.",
                        "start": 0,
                        "step": 1,
                        "stop": 1,
                        "width": 1,
                    },
                    "tx_header_update": {
                        "access_mode": "RW",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Select the data path post HBM playout, 0 : HBM -> 100G, 1 : HBM -> CODIF update logic -> 100G) Set this before setting tx_enable to 1.",
                        "start": 6,
                        "step": 1,
                        "stop": 7,
                        "width": 8,
                    },
                    "tx_loop_count": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Current status (number) of the loop counter",
                        "start": 5,
                        "step": 1,
                        "stop": 6,
                        "width": 32,
                    },
                    "tx_loop_enable": {
                        "access_mode": "RW",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "1: Loop traffic",
                        "start": 2,
                        "step": 1,
                        "stop": 3,
                        "width": 1,
                    },
                    "tx_looping": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Looping is running",
                        "start": 3,
                        "step": 1,
                        "stop": 4,
                        "width": 1,
                    },
                    "tx_loops": {
                        "access_mode": "RW",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Number of loops to do",
                        "start": 4,
                        "step": 1,
                        "stop": 5,
                        "width": 32,
                    },
                    "tx_packet_count_hi": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "number of packets read out of fifo upper 32 bits of 64 bit counter, current loop",
                        "start": 22,
                        "step": 1,
                        "stop": 23,
                        "width": 32,
                    },
                    "tx_packet_count_lo": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "number of packets read out of fifo lower 32 bits of 64 bit counter, current loop",
                        "start": 23,
                        "step": 1,
                        "stop": 24,
                        "width": 32,
                    },
                    "tx_packet_size": {
                        "access_mode": "RW",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "size of the complete packet including ethernet header, spead header etc",
                        "start": 11,
                        "step": 1,
                        "stop": 12,
                        "width": 32,
                    },
                    "tx_packet_to_send": {
                        "access_mode": "RW",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Total number of TX packets to play out",
                        "start": 12,
                        "step": 1,
                        "stop": 13,
                        "width": 32,
                    },
                    "tx_packet_type": {
                        "access_mode": "RW",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "0 :RAW pcap (full ethernet packet), 2: SPEAD pcap, 3 CODIF pcap",
                        "start": 10,
                        "step": 1,
                        "stop": 11,
                        "width": 4,
                    },
                    "tx_packets_per_burst": {
                        "access_mode": "RW",
                        "bit_offset": 0,
                        "default": 1,
                        "description": "This is a parameter for how much data the FIFO in HBM controller caches before sending. Harcode to 1 currently.",
                        "start": 17,
                        "step": 1,
                        "stop": 18,
                        "width": 32,
                    },
                    "tx_packets_to_mac_hi": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "count of the total number of packets sent to the 100G MAC, upper 32 bits of 64 bit counter",
                        "start": 24,
                        "step": 1,
                        "stop": 25,
                        "width": 32,
                    },
                    "tx_packets_to_mac_lo": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "count of the total number of packets sent to the 100G MAC, lower 32 bits of 64 bit counter",
                        "start": 25,
                        "step": 1,
                        "stop": 26,
                        "width": 32,
                    },
                    "tx_running": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Hardware feedback of tx_enable",
                        "start": 1,
                        "step": 1,
                        "stop": 2,
                        "width": 1,
                    },
                },
                "start": 0,
                "step": 50,
                "stop": 50,
                "type": "REG",
            }
        },
        "start": 65536,
        "step": 50,
        "stop": 65586,
    },
    "system": {
        "slaves": {
            "system": {
                "fields": {
                    "args_magic_number": {
                        "access_mode": "SP",
                        "bit_offset": 0,
                        "default": 4184502273,
                        "description": "args magic number for address 0",
                        "start": 0,
                        "step": 1,
                        "stop": 1,
                        "width": 32,
                    },
                    "args_map_build": {
                        "access_mode": "SP",
                        "bit_offset": 0,
                        "default": 570956065,
                        "description": "args map build date & hour",
                        "start": 1,
                        "step": 1,
                        "stop": 2,
                        "width": 32,
                    },
                    "build_date": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Build Date of firmware, Day/Month/Year, readable in HEX, hand coded and not tied to autogeneration currently",
                        "start": 4,
                        "step": 1,
                        "stop": 5,
                        "width": 32,
                    },
                    "eth100g_b_locked": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "2nd (U55C lower port) 100G ethernet is up",
                        "start": 22,
                        "step": 1,
                        "stop": 23,
                        "width": 1,
                    },
                    "eth100g_b_ptp_lower_seconds": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "lower 32-bits of 48 bit second time vector",
                        "start": 15,
                        "step": 1,
                        "stop": 16,
                        "width": 32,
                    },
                    "eth100g_b_ptp_nano_seconds": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "nanoseconds value range o to 999,999,999",
                        "start": 14,
                        "step": 1,
                        "stop": 15,
                        "width": 32,
                    },
                    "eth100g_b_ptp_upper_seconds": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "upper 16-bits of 48 bit second time vector",
                        "start": 16,
                        "step": 1,
                        "stop": 17,
                        "width": 32,
                    },
                    "eth100g_b_rx_bad_code": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Total packets received on the 2nd (U55C lower port) 100G ethernet with 64B/66B code violations",
                        "start": 25,
                        "step": 1,
                        "stop": 26,
                        "width": 32,
                    },
                    "eth100g_b_rx_bad_fcs": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Total packets received on the 2nd (U55C lower port) 100G ethernet with bad FCS since it was reset",
                        "start": 24,
                        "step": 1,
                        "stop": 25,
                        "width": 32,
                    },
                    "eth100g_b_rx_total_packets": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Total packets received on the 2nd (U55C lower port) 100G ethernet since it was reset",
                        "start": 23,
                        "step": 1,
                        "stop": 24,
                        "width": 32,
                    },
                    "eth100g_b_tx_total_packets": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Total packets sent on the 2nd (U55C lower port) 100G ethernet since it was reset",
                        "start": 26,
                        "step": 1,
                        "stop": 27,
                        "width": 32,
                    },
                    "eth100g_fec_enable": {
                        "access_mode": "RW",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Enable FEC on 100G interfaces.",
                        "start": 27,
                        "step": 1,
                        "stop": 28,
                        "width": 1,
                    },
                    "eth100g_locked": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "100G ethernet is up",
                        "start": 17,
                        "step": 1,
                        "stop": 18,
                        "width": 1,
                    },
                    "eth100g_ptp_lower_seconds": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "lower 32-bits of 48 bit second time vector",
                        "start": 12,
                        "step": 1,
                        "stop": 13,
                        "width": 32,
                    },
                    "eth100g_ptp_nano_seconds": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "nanoseconds value range o to 999,999,999",
                        "start": 11,
                        "step": 1,
                        "stop": 12,
                        "width": 32,
                    },
                    "eth100g_ptp_upper_seconds": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "upper 16-bits of 48 bit second time vector",
                        "start": 13,
                        "step": 1,
                        "stop": 14,
                        "width": 32,
                    },
                    "eth100g_rx_bad_code": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Total packets received on the 100G ethernet with 64B/66B code violations",
                        "start": 20,
                        "step": 1,
                        "stop": 21,
                        "width": 32,
                    },
                    "eth100g_rx_bad_fcs": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Total packets received on the 100G ethernet with bad FCS since it was reset",
                        "start": 19,
                        "step": 1,
                        "stop": 20,
                        "width": 32,
                    },
                    "eth100g_rx_total_packets": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Total packets received on the 100G ethernet since it was reset",
                        "start": 18,
                        "step": 1,
                        "stop": 19,
                        "width": 32,
                    },
                    "eth100g_tx_total_packets": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Total packets sent on the 100G ethernet since it was reset",
                        "start": 21,
                        "step": 1,
                        "stop": 22,
                        "width": 32,
                    },
                    "firmware_label": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Firmware Label",
                        "start": 8,
                        "step": 1,
                        "stop": 9,
                        "width": 32,
                    },
                    "firmware_major_version": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Major version number",
                        "start": 5,
                        "step": 1,
                        "stop": 6,
                        "width": 16,
                    },
                    "firmware_minor_version": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Minor version number",
                        "start": 6,
                        "step": 1,
                        "stop": 7,
                        "width": 16,
                    },
                    "firmware_patch_version": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Patch version number",
                        "start": 7,
                        "step": 1,
                        "stop": 8,
                        "width": 16,
                    },
                    "firmware_personality": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Firmware function - PST/PSS/ZOOM/CORR",
                        "start": 9,
                        "step": 1,
                        "stop": 10,
                        "width": 32,
                    },
                    "qsfpgty_resets": {
                        "access_mode": "RW",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Reset all 100G ethernet interface",
                        "start": 3,
                        "step": 1,
                        "stop": 4,
                        "width": 1,
                    },
                    "status_clocks_locked": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "All clocks locked",
                        "start": 2,
                        "step": 1,
                        "stop": 3,
                        "width": 1,
                    },
                    "time_uptime": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Number of seconds since programming",
                        "start": 10,
                        "step": 1,
                        "stop": 11,
                        "width": 32,
                    },
                },
                "start": 0,
                "step": 28,
                "stop": 28,
                "type": "REG",
            }
        },
        "start": 0,
        "step": 28,
        "stop": 28,
    },
    "timeslave": {
        "slaves": {
            "timeslave_scheduler": {
                "fields": {
                    "current_ptp_seconds_lower": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Live feed from hardware clock bits 63 -> 32 ... bit 32 = 1 sec",
                        "start": 1,
                        "step": 1,
                        "stop": 2,
                        "width": 32,
                    },
                    "current_ptp_seconds_upper": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Live feed from hardware clock 0x0000 & bits 79 -> 64 ... Upper 16 bits of 80 bit time vector, upper section of seconds.",
                        "start": 2,
                        "step": 1,
                        "stop": 3,
                        "width": 32,
                    },
                    "current_ptp_sub_seconds": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Live feed from hardware clock bits 31 -> 0 ... bit 31 = 1/2 sec, bit 30 = 1/4 sec and so on...",
                        "start": 0,
                        "step": 1,
                        "stop": 1,
                        "width": 32,
                    },
                    "rx_start_ptp_seconds_lower": {
                        "access_mode": "RW",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Target start time bits 63 -> 32 ... bit 32 = 1 sec",
                        "start": 10,
                        "step": 1,
                        "stop": 11,
                        "width": 32,
                    },
                    "rx_start_ptp_seconds_upper": {
                        "access_mode": "RW",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Target start time 0x0000 & bits 79 -> 64 ... Upper 16 bits of 80 bit time vector, upper section of seconds.",
                        "start": 11,
                        "step": 1,
                        "stop": 12,
                        "width": 32,
                    },
                    "rx_start_ptp_sub_seconds": {
                        "access_mode": "RW",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Target start time bits 31 -> 0 ... number of nanoseconds, max value of 999,999,999",
                        "start": 9,
                        "step": 1,
                        "stop": 10,
                        "width": 32,
                    },
                    "rx_stop_ptp_seconds_lower": {
                        "access_mode": "RW",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Target start time bits 63 -> 32 ... bit 32 = 1 sec",
                        "start": 13,
                        "step": 1,
                        "stop": 14,
                        "width": 32,
                    },
                    "rx_stop_ptp_seconds_upper": {
                        "access_mode": "RW",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Target start time 0x0000 & bits 79 -> 64 ... Upper 16 bits of 80 bit time vector, upper section of seconds.",
                        "start": 14,
                        "step": 1,
                        "stop": 15,
                        "width": 32,
                    },
                    "rx_stop_ptp_sub_seconds": {
                        "access_mode": "RW",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Target start time bits 31 -> 0 ... number of nanoseconds, max value of 999,999,999",
                        "start": 12,
                        "step": 1,
                        "stop": 13,
                        "width": 32,
                    },
                    "schedule_control_reset": {
                        "access_mode": "RW",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Reset the scheduler",
                        "start": 15,
                        "step": 1,
                        "stop": 16,
                        "width": 1,
                    },
                    "schedule_control_rx_start_time": {
                        "access_mode": "RW",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Enable RX start time",
                        "start": 18,
                        "step": 1,
                        "stop": 19,
                        "width": 1,
                    },
                    "schedule_control_rx_stop_time": {
                        "access_mode": "RW",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Enable RX stop time",
                        "start": 19,
                        "step": 1,
                        "stop": 20,
                        "width": 1,
                    },
                    "schedule_control_tx_start_time": {
                        "access_mode": "RW",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Enable TX start time",
                        "start": 16,
                        "step": 1,
                        "stop": 17,
                        "width": 1,
                    },
                    "schedule_control_tx_stop_time": {
                        "access_mode": "RW",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Enable TX stop time",
                        "start": 17,
                        "step": 1,
                        "stop": 18,
                        "width": 1,
                    },
                    "schedule_debug_complete": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "SM in complete state.",
                        "start": 27,
                        "step": 1,
                        "stop": 28,
                        "width": 1,
                    },
                    "schedule_debug_error": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "error condition, eg time scheduled and real time is already in the future.",
                        "start": 25,
                        "step": 1,
                        "stop": 26,
                        "width": 1,
                    },
                    "schedule_debug_reset": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "in reset state",
                        "start": 26,
                        "step": 1,
                        "stop": 27,
                        "width": 1,
                    },
                    "schedule_debug_running": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Running state, 1 - running ... 0 - stopped , ie waiting for time",
                        "start": 20,
                        "step": 1,
                        "stop": 21,
                        "width": 1,
                    },
                    "schedule_debug_rx_start": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "RX start achieved",
                        "start": 23,
                        "step": 1,
                        "stop": 24,
                        "width": 1,
                    },
                    "schedule_debug_rx_stop": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "RX stop achieved",
                        "start": 24,
                        "step": 1,
                        "stop": 25,
                        "width": 1,
                    },
                    "schedule_debug_tx_start": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "TX start achieved",
                        "start": 21,
                        "step": 1,
                        "stop": 22,
                        "width": 1,
                    },
                    "schedule_debug_tx_stop": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "TX stop achieved",
                        "start": 22,
                        "step": 1,
                        "stop": 23,
                        "width": 1,
                    },
                    "tx_start_ptp_seconds_lower": {
                        "access_mode": "RW",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Target start time bits 63 -> 32 ... bit 32 = 1 sec",
                        "start": 4,
                        "step": 1,
                        "stop": 5,
                        "width": 32,
                    },
                    "tx_start_ptp_seconds_upper": {
                        "access_mode": "RW",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Target start time 0x0000 & bits 79 -> 64 ... Upper 16 bits of 80 bit time vector, upper section of seconds.",
                        "start": 5,
                        "step": 1,
                        "stop": 6,
                        "width": 32,
                    },
                    "tx_start_ptp_sub_seconds": {
                        "access_mode": "RW",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Target start time bits 31 -> 0 ... number of nanoseconds, max value of 999,999,999",
                        "start": 3,
                        "step": 1,
                        "stop": 4,
                        "width": 32,
                    },
                    "tx_stop_ptp_seconds_lower": {
                        "access_mode": "RW",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Target start time bits 63 -> 32 ... bit 32 = 1 sec",
                        "start": 7,
                        "step": 1,
                        "stop": 8,
                        "width": 32,
                    },
                    "tx_stop_ptp_seconds_upper": {
                        "access_mode": "RW",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Target start time 0x0000 & bits 79 -> 64 ... Upper 16 bits of 80 bit time vector, upper section of seconds.",
                        "start": 8,
                        "step": 1,
                        "stop": 9,
                        "width": 32,
                    },
                    "tx_stop_ptp_sub_seconds": {
                        "access_mode": "RW",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Target start time bits 31 -> 0 ... number of nanoseconds, max value of 999,999,999",
                        "start": 6,
                        "step": 1,
                        "stop": 7,
                        "width": 32,
                    },
                },
                "start": 65536,
                "step": 28,
                "stop": 65564,
                "type": "REG",
            },
            "timeslave_space": {
                "fields": {
                    "data": {
                        "access_mode": "RW",
                        "bit_offset": 32,
                        "default": 0,
                        "description": " Shared memory space starts at 0x2_0000 and has range 32K Only some sections are valid refer to VHDL for map. Address space is used in 4 bytes. 0xdec0de1c is returned if the address space is not used. ",
                        "start": 0,
                        "step": 1,
                        "stop": 65536,
                        "width": 32,
                    }
                },
                "start": 0,
                "step": 65536,
                "stop": 65536,
                "type": "RAM",
            },
        },
        "start": 131072,
        "step": 65564,
        "stop": 196636,
    },
    "timeslave_b": {
        "slaves": {
            "timeslave_scheduler": {
                "fields": {
                    "current_ptp_seconds_lower": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Live feed from hardware clock bits 63 -> 32 ... bit 32 = 1 sec",
                        "start": 1,
                        "step": 1,
                        "stop": 2,
                        "width": 32,
                    },
                    "current_ptp_seconds_upper": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Live feed from hardware clock 0x0000 & bits 79 -> 64 ... Upper 16 bits of 80 bit time vector, upper section of seconds.",
                        "start": 2,
                        "step": 1,
                        "stop": 3,
                        "width": 32,
                    },
                    "current_ptp_sub_seconds": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Live feed from hardware clock bits 31 -> 0 ... bit 31 = 1/2 sec, bit 30 = 1/4 sec and so on...",
                        "start": 0,
                        "step": 1,
                        "stop": 1,
                        "width": 32,
                    },
                    "schedule_control": {
                        "access_mode": "RW",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Multi bit control vector that will allow different operations of scheduled hardware actions. Assumes a valid future time has been set in the schedule_ptp_xxxx fields above. This register will be "
                        "polled and update the operations accordingly, will throttle update operations to every 1us. Bit 0 = reset logic to be scheduled, this will run a 100us reset pulse at the start of the run. Bit 1 = "
                        "start run. Bit 2 = end current run. ",
                        "start": 6,
                        "step": 1,
                        "stop": 7,
                        "width": 32,
                    },
                    "schedule_debug": {
                        "access_mode": "RO",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "Feedback from hardware.. Bit 0 = Running state, 1 - running ... 0 - stopped Bit 1 = waiting to reach start time Bit 2 = past start time Bit 3 = error condition",
                        "start": 7,
                        "step": 1,
                        "stop": 8,
                        "width": 32,
                    },
                    "schedule_ptp_seconds_lower": {
                        "access_mode": "RW",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "bits 63 -> 32 ... bit 32 = 1 sec",
                        "start": 4,
                        "step": 1,
                        "stop": 5,
                        "width": 32,
                    },
                    "schedule_ptp_seconds_upper": {
                        "access_mode": "RW",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "0x0000 & bits 79 -> 64 ... Upper 16 bits of 80 bit time vector, upper section of seconds.",
                        "start": 5,
                        "step": 1,
                        "stop": 6,
                        "width": 32,
                    },
                    "schedule_ptp_sub_seconds": {
                        "access_mode": "RW",
                        "bit_offset": 0,
                        "default": 0,
                        "description": "bits 31 -> 0 ... bit 31 = 1/2 sec, bit 30 = 1/4 sec and so on...",
                        "start": 3,
                        "step": 1,
                        "stop": 4,
                        "width": 32,
                    },
                },
                "start": 65536,
                "step": 8,
                "stop": 65544,
                "type": "REG",
            },
            "timeslave_space": {
                "fields": {
                    "data": {
                        "access_mode": "RW",
                        "bit_offset": 32,
                        "default": 0,
                        "description": " Shared memory space starts at 0x2_0000 and has range 32K Only some sections are valid refer to VHDL for map. Address space is used in 4 bytes. 0xdec0de1c is returned if the address space is not used. ",
                        "start": 0,
                        "step": 1,
                        "stop": 65536,
                        "width": 32,
                    }
                },
                "start": 0,
                "step": 65536,
                "stop": 65536,
                "type": "RAM",
            },
        },
        "start": 262144,
        "step": 65544,
        "stop": 327688,
    },
    "vitis_shared": {
        "slaves": {
            "vitis_shared": {
                "fields": {
                    "data": {
                        "access_mode": "RW",
                        "bit_offset": 32,
                        "default": 0,
                        "description": "128 Kbyte page to access the registers. Copy data to/from this memory using the CDMA core.",
                        "start": 0,
                        "step": 1,
                        "stop": 32768,
                        "width": 32,
                    }
                },
                "start": 0,
                "step": 32768,
                "stop": 32768,
                "type": "RAM",
            }
        },
        "start": 32768,
        "step": 32768,
        "stop": 65536,
    },
}
